{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-aarch64","name":"Example","functions":[{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"zZ3dTltJEITfxddcTP9M9zSvslpFJCGRJQQRkJVWiHdfzGKzWe/aGp3USd0gGXo+FeJUa9o1jJ82n68/fv/6YXv75e5hc/nb0+bm7tPV4/bu9uXV0/PF5uP99uZm+/XDP7+9absv0l7rH75d3e5ePjxe3T9uLrUuNte3nzeX5i+rv2xvrjeX2Z5/v9iIzNVrTNRfHBWOIf5WOkbvh2LReqUnlD6g9ELSrUHpAqXr3DNmNlnvk/V9sj4m63OyfkzW11y9T/YEX/Y0qIu+laqrHIpN45WuULpB6b7MJ4fK4e+lOuy/aiX3td1+qN3p6CQ6gkRHkugYJDqKQ0dvJDqERIeS6Fivf/S0t9qefqRjPb/0sa/tNY50FIeOWM8v4fvnI+Lo+Qgh0aEkOoxEh5Po6CQ6gkRHkugYJDqKQ0eS9NMk6adJ0k9zYT/9373N9ESXTqOk0ygJkJIdO4HsAWQv62gS1d5KJVs7XdzVD3tEjR/fTjuuTm/76nTT53+9+TYaSvgOLki4IuGGhC9sKvXeZ6v70V+0Q+kBpSeUPqD0QtKrQekCpSuUPuOmXf3k2/sFjYUKGgtJa1i8YPGKxRsWP/lgSuuzC2J2Qc4uGLMLJsMnmU+kZXaBzi6AhkQijsV3LJ4k0xEhCXVESFIdEZJYR5Qk1xElCXZESZIdUWMR4ixC1usjJ8MusfVcczJlEhMWISTvR4qRBDxiziKEJOIRI8l4xEhCHjGSlEeMJOYRJ8l5xEmCHnGWzuosndVZOqvTBD3iwSMleaQAcyRZejTvJHzpebvTcFjYA47ApCOTJOkGpTuU3qH0gNKhWZL0gcVD0ySJhsULFq9YvGHxjsV3LH42QojZCCGxoVJiQ6XEhkpLDySdw3csPrD42Wczp5/N2XhrzMZbYzbeGrPx1rDZBT67YDbIXHiq5NyOfeGxkrP4gcWzxDrFEusUS6xTLLFOscQ6U6dxoEJI/gdSiiUwL5LAXNuKQdepxE3beq45GXRpcxYhJLGONpJYRxtJrKONJNbRRhLrqJDEOioksY4KSayjQhLrqDiLEJbOKiydVVg6q6ACnelZT6VopGjjkSIgKa9wRcINCV/W235d4qaKzJVUA0pPKH1ZLzKTQ2Xj/fMXwS+5E7LwyOVPFCIsQpRFiK3X3H6hFcwpfs1XKZ1HSvBISR4p0CMHatAjB+oNixcsXrF4w+Idi+9YfGDxy2yV+9El81DY38iFIi88yXeKLDCywsgGIzuM3GHkgJETRoZ5sMM8GDAPBsyDAfNgwDwYMA8GzIMB82DAPBgwDwbMgwnzYMI8mDAPJsyDCfNgwjyYMA8mzIMJ82DCPDhgHhwwDw6YBwfMgwPmwQHz4IB5cMA8OGAeHDAPFsyDBfNgwTxYMA8WzIMF82DBPFgwDxbMg4XyoLUGIwuMrDCywcgOI3cYOWDkhJEHjAzzoMA8KDAPCsyDAvOgwDwoMA8KzIMC8+CKV7qdPCpvSnJm31a80u2MkBXP2sr+VEVoHAsxFiHOIqSzCFnxrG17F5LHQpJFyGARUiRCVrz274wQYRGiLEJI/j/MVrz274yQziIkWIQkixCSD8szI/m0PHOSC1XNSS5UtRWv/TsjhKWzOktndZbO6iyd1Vk6q7N01s4y+674QbVnhBiLECcZOTvL7NuDRUiyCGGZfTvL7Bsss2+wzL7BMvuu+ZnGp4U4ixCWHVqw7NCCZYcWLDu0YJl9k2X2TZbZN1lm32SZfdNZhLB01mTprMnSWZOlsyZLZx0snXWwzL7DWYR0FiEss+9gmX3HYBFSJEKKZfYtltm3WGbfYpl9V7xN94yQziKE5URNsezQimWHViQ7NG8kOzRvJLOvN5LZ11luXPbmLEJIZl9vJLOvN5LO6o2ks3pj6azC0lmFpbMKRWd9fnn5x9X99urjzfXDy5LdT7/ffnrc3t2+vXz889vfP3kp/gs=","brillig_names":["public_dispatch"],"assert_messages":{"227":"Function quadruple can only be called statically","154":"Function triple can only be called statically","325":"attempt to add with overflow","357":"attempt to add with overflow","63":"attempt to add with overflow","389":"attempt to add with overflow","418":"Stack too deep","208":"attempt to add with overflow","336":"Array index out of bounds","368":"Array index out of bounds","135":"attempt to add with overflow","231":"Function double can only be called statically","400":"Array index out of bounds","347":"attempt to add with overflow","379":"attempt to add with overflow","411":"attempt to add with overflow","82":"Function double can only be called statically","236":"Function double can only be called statically","393":"Array index out of bounds","361":"Array index out of bounds","329":"Array index out of bounds"}},{"name":"double","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAorBAABgEQ4AIBEAAEiABQeAgoAAiQCAAEDCjgCAwQhAgAQAAQ5AQAAJAIAAgIEOAECAyoMAwEjJQAEeACABA0AAACABIADIQAAGIADOQEAACMrABjKGMo=","debug_symbols":"nZLRCoMgFIbf5Vx3oaZJvcoYYWUhiIXaYEjvPt3aaGw3eSPn1++TA+cEGGS3Tq0y4+yguQTQcy+8mk1MYSugs0prNbXHa0DpwPjJu0WYFJ0X1kODqxoVIM0QS45Q/GFUWkLDY/kDM0LrHWakYh8Yk/oPzSl605yW5Iu+FoDJyX6SU2Y4NMNhGU6V4fCzzhbTTVglOi33kY+r6Q8b4O/L6yXCDw==","brillig_names":["double"],"assert_messages":{"15":"Function double can only be called statically","23":"Stack too deep"}},{"name":"triple","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAorBAABgEQ4AIBEAAEiABQeAgoAAiQCAAEDCjgCAwQhAgAQAAQ5AQAAJAIAAwIEOAECAyoMAwEjJQAEeACABA0AAACABIADIQAAGIADOQEAACMrABjKGMo=","debug_symbols":"nZLRCoMgFIbf5Vx3oaZJvcoYYWUhiIXaYEjvPt3aaGw3eSPn1++TA+cEGGS3Tq0y4+yguQTQcy+8mk1MYSugs0prNbXHa0DpwPjJu0WYFJ0X1kODqxoVIM0QS45Q/GFUWkLDY/kDM0LrHWakYh8Yk/oPzSl605yW5Iu+FoDJyX6SU2Y4NMNhGU6V4fCzzhbTTVglOi33kY+r6Q8b4O/L6yXCDw==","brillig_names":["triple"],"assert_messages":{"15":"Function triple can only be called statically","23":"Stack too deep"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VYzXLaMBAWYDB2AiEmKemNXtuLnRCgN8/0J733CRp+Lj2knckDuDNtn7uoaO2PZctQWB3YGY9krfztt7uS11bNrKW9umqu33Rty2wLzcldmx4nmSJW6pNn7UR41k+EZ+NEeAaKPGsCT9sGrm/3nd1zoVnvxy0lPmwT3QC92QFUY0at/IR+17Wfn7/Mvg6fn56G88XiWzn9t2sj19YBTjGPWWS2Y6OFP01Hs8hsijL/u8hhhn7w7wm/7Qc/Jd7vigoffSG7Ddc+FFUsH+AZKx3XxyVHuKSrg+490zVA94HpcMl/ZDrcJsSJ4tYCXxTX1dR3Xsi3EHyr/aM1poodjlGsY+N1jWaU84jx4fyJT4fmFBWfFtMFoIuYrgk6ir9thzCP5z6EeW9gnK/Jhtlew6SnnGOsfaypwAP+SkZS3HlOgmLTNuow7gHEc+j6/dX1yc0JIGZWwsKLT2V9bTv8JvAmm8i9zubzfpONvTYV77/+wFyy04Axsnnh7lugo2d3YQUCVk+Y32JYoYCFY+S33ROvXP/MrPP3g/DN9ntC7xt4/FZ6Z+rhT8paHPnhvyD82Av+qMQ/A3zNvUL4537iMyb8jh/88luo6wX/tozPBeAbvfhnVJdoP6MNsn3pJfdZts83A9qPGVdf3wyXjA+PD9Ynq0sErj1Bx/doIthJBDuUhz57Plfxe7yUuPYP5CphdRWxIkWsQ32kfFyx53N3nx4lk5HE9UrR744iVlsR69B1Qvm4Zs/n7j49SsZiPq4V/dbMx7kiVqiIpblvNeNFeZRqnZXctemRwrni/xTapDrfZPO/u5ZqzgtTCa/XAxhXrNe3+9brAeOKfIh3LOiOOeOcjZd3j/PlaP44WUwh3gPGlY/hGaK9boT5Uu2nWL80XmKdSv/FNxBXKwHoBkzXBB1xxP/iiGFq898n/mi/J+jwn+N/cpmYzbWWMJ/x/CdX8bc6G2sDNt+XkZdYp/f77kuyHzOuynx2nr1hfPh3dCxw7Qk6XpdiwU4s2DlFLH5+jTG0+4PiFBSVXiuXk2l1lkXvITzLQglAj/N/ufvEyGJ9+ANQAijv/B0AAA==","debug_symbols":"tdnBaoNAEIDhd9mzB1fdnRlfpZSgiYYF0aCmUMR3r2lDCeT8X4RxZ//bd9rNXbr2fj2lsZ8WV39sbpjOzZqm8Zi2PXPtnIYhXU+vv13++FTV7/5ya8bHuKzNvLq6sMx148XVZXXc7tPQuVryPXtblOK5KPK/GGz/zFwVqHCkwkKFlQobFA45FfZUuKDCJRWm5AVKXqDkBUpeoOQFSl6k5EVKXqTkRUpepORFSl6k5EVKXqTkRUqeUPKEkieUPKHkCSVPKHlCyRNKnlDyhJKnlDyl5CklTyl5SslTSp5S8pSSp5Q8peQZJc8oeUbJM0qeUfKMkmeUPKPkGSXPKHk+z7Gyx8oFVi6xcoWVA1aOWFmwsmJlzKDHDHrMoGcM7sf01cypaYfu+WjQ38fzyxvC+n37OzmWfwA=","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"quadruple","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAorBAABgEQ4AIBEAAEiABweAgoAAiQCAAEDCjgCAwQhAgAQAAQ5AQAAHgIKAAIKOAIDBCECABQABDkBAAAkAgACAgQ4AQIEHgIKAAEKOAEDBSECABoABTkBAAAEOAQCASMlAAR4AIAEDQAAAIAEgAMhAAAggAM5AQAAIysAGMoYyg==","debug_symbols":"xZVbCsIwEEX3Mt/9yLOx3YqIpNqWQEhLH4KU7t1Eq1QsiJWhPyGTnHtnyIMZ4JxnfXk0rqhaSPcD2OqkO1M5Hw1jBFljrDXlcb4MJAyU3vm21i6EbaebDlIaJySC3J39VBHiHQpjc0iVn37AkolkgiWL5QumLFmglSBPWgnO3uhDBJT9WE/Q8BUasUIjV2jiJQ3ndJJw8eV0N7wKhVd6sN/h2ieo9ozg2lNce/b3r9/uXTKOWXxIILATSOwEMWqC0UcX3Rid2XzqMEXvTrOG013rx46Hbw==","brillig_names":["quadruple"],"assert_messages":{"15":"Function quadruple can only be called statically","31":"Stack too deep","25":"Function double can only be called statically","19":"Function double can only be called statically"}}],"outputs":{"globals":{},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"x","type":{"kind":"field"}}],"kind":"struct","path":"Example::triple_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Example::triple_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"x","type":{"kind":"field"}}],"kind":"struct","path":"Example::quadruple_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Example::quadruple_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"x","type":{"kind":"field"}}],"kind":"struct","path":"Example::double_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Example::double_abi"}]}},"file_map":{"129":{"path":"/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-package-v0.60.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"283":{"path":"/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-package-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"326":{"path":"/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-package-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"70":{"path":"/home/vscode/example/contract/src/main.nr","source":"use aztec::macros::aztec;\n\n#[aztec]\ncontract Example {\n    use aztec::macros::functions::{ public, view };\n\n    #[public]\n    #[view]\n    fn double(x: Field) -> pub Field { x * 2 }\n\n    #[public]\n    #[view]\n    fn triple(x: Field) -> pub Field { x * 3 }\n\n    #[public]\n    #[view]\n    fn quadruple(x: Field) -> pub Field { double(double(x)) }\n}\n"}}}